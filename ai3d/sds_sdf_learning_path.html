<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>基于 Kaolin 的 SDS + SDF 学习路径（工程向）</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, "Helvetica Neue", Arial;
      line-height: 1.7;
      margin: 40px;
      max-width: 1100px;
    }
    h1, h2, h3 {
      border-left: 4px solid #333;
      padding-left: 12px;
    }
    code, pre {
      background: #f6f8fa;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.95em;
    }
    pre {
      padding: 12px;
      overflow-x: auto;
    }
    .stage {
      border: 1px solid #ddd;
      padding: 20px;
      margin: 24px 0;
      border-radius: 6px;
    }
    .output {
      background: #fafafa;
      border-left: 4px solid #999;
      padding: 10px 14px;
      margin-top: 10px;
    }
  </style>
</head>

<body>

<h1>基于 Kaolin 的 SDS + SDF 学习路径（偏工程）</h1>

<p>
目标：<strong>从 0 到 1，真正跑通并理解</strong>
</p>

<pre>
Camera Sampling
→ Ray Generation
→ SDF Evaluation
→ Ray Marching / Surface Hit
→ Differentiable Rendering
→ SDS Loss
→ Backprop 更新 SDF
</pre>

<p><strong>核心框架选型：</strong>Kaolin + PyTorch + 外部 Diffusion</p>

<hr/>

<!-- Stage 0 -->
<div class="stage">
<h2>阶段 0：建立完整心智模型（不要跳过）</h2>

<h3>目标</h3>
<p>
在动手前，脑中必须存在<strong>完整梯度闭环</strong>，而不是“模块拼接感”。
</p>

<h3>必须掌握</h3>
<ul>
  <li>SDF 是连续几何的 zero-level set，不是 mesh</li>
  <li>Ray-based rendering 是梯度通道，而非显示工具</li>
  <li>SDS 是“借用 2D 扩散模型的 score”，不是监督 loss</li>
</ul>

<div class="output">
<strong>阶段产出：</strong>  
能在纸上画出：SDF → image → SDS → ∂θ 的完整路径
</div>
</div>

<!-- Stage 1 -->
<div class="stage">
<h2>阶段 1：Camera 与 Ray Sampling（与 AI 无关）</h2>

<h3>目标</h3>
<p>
自己实现一套<strong>相机采样 + 像素射线生成</strong>代码。
</p>

<h3>必须掌握</h3>
<ul>
  <li>Camera extrinsic / intrinsic</li>
  <li>World → Camera → Ray</li>
  <li>随机视角采样的必要性（防止形状坍缩）</li>
</ul>

<h3>工程要求</h3>
<pre>
Input : camera pose + intrinsics
Output: rays_o (N,3), rays_d (N,3)
</pre>

<div class="output">
<strong>阶段产出：</strong>  
一个独立的 <code>camera.py</code>，不依赖 Kaolin
</div>
</div>

<!-- Stage 2 -->
<div class="stage">
<h2>阶段 2：SDF 网络与几何约束</h2>

<h3>目标</h3>
<p>
构建<strong>可被优化的连续 SDF 表示</strong>。
</p>

<h3>必须掌握</h3>
<ul>
  <li>SDF MLP（x → sdf(x)）</li>
  <li>Positional Encoding（可选）</li>
  <li>Eikonal Loss：||∇SDF|| ≈ 1</li>
</ul>

<h3>工程要点</h3>
<pre>
loss_eikonal = (||∇sdf|| - 1)^2
</pre>

<div class="output">
<strong>阶段产出：</strong>  
一个稳定输出 signed distance 的 SDF 网络
</div>
</div>

<!-- Stage 3 -->
<div class="stage">
<h2>阶段 3：基于 Kaolin 的 Ray Marching</h2>

<h3>目标</h3>
<p>
打通<strong>Ray → SDF → Surface Hit → Gradient</strong>。
</p>

<h3>Kaolin 使用点</h3>
<ul>
  <li>SDF-based ray tracing / sphere tracing</li>
  <li>命中点与 SDF 参数的可微关系</li>
</ul>

<h3>关键理解</h3>
<p>
<strong>渲染结果是否好看不重要，梯度是否稳定才重要。</strong>
</p>

<div class="output">
<strong>阶段产出：</strong>  
能稳定返回 hit points + normals，并可反传
</div>
</div>

<!-- Stage 4 -->
<div class="stage">
<h2>阶段 4：Differentiable Rendering（极简）</h2>

<h3>目标</h3>
<p>
生成可送入 Diffusion 的 image tensor。
</p>

<h3>推荐最小渲染</h3>
<ul>
  <li>Silhouette（alpha）</li>
  <li>Normal-based shading</li>
  <li>单通道或 RGB</li>
</ul>

<h3>注意</h3>
<p>
SDS 不需要 photorealism，只需要<strong>语义可识别结构</strong>。
</p>

<div class="output">
<strong>阶段产出：</strong>  
<code>render(points, normals) → image</code>
</div>
</div>

<!-- Stage 5 -->
<div class="stage">
<h2>阶段 5：SDS Loss 接入（关键阶段）</h2>

<h3>目标</h3>
<p>
让 2D 扩散模型的 score 成为 3D SDF 的优化信号。
</p>

<h3>必须掌握</h3>
<ul>
  <li>timestep 采样</li>
  <li>noise schedule</li>
  <li>SDS 权重调度</li>
</ul>

<h3>梯度路径</h3>
<pre>
SDS loss
→ image
→ hit points
→ sdf(x)
→ SDF parameters
</pre>

<div class="output">
<strong>阶段产出：</strong>  
loss.backward() 后，SDF 参数发生有意义变化
</div>
</div>

<!-- Stage 6 -->
<div class="stage">
<h2>阶段 6：稳定性与工程化</h2>

<h3>必须处理的问题</h3>
<ul>
  <li>形状 hollow / blob</li>
  <li>拓扑崩坏</li>
  <li>多视角一致性</li>
</ul>

<h3>工程手段</h3>
<ul>
  <li>Camera sampling 扩展</li>
  <li>SDF 正则项权重控制</li>
  <li>SDS 强度分阶段开启</li>
</ul>

<div class="output">
<strong>阶段产出：</strong>  
一个可重复生成、可 debug 的 SDS + SDF 系统
</div>
</div>

<hr/>

<h2>最终能力检验</h2>
<ul>
  <li>你能否快速判断：形状问题来自采样 / 渲染 / SDS？</li>
  <li>你是否可以替换 Diffusion 而不动渲染？</li>
  <li>你是否理解：SDS 为什么不是监督 loss？</li>
</ul>

<p>
如果三者答案都是“是”，说明你已经真正掌握这条路径。
</p>

</body>
</html>
